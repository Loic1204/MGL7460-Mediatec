#!/usr/bin/env ruby
require 'gli'
begin # XXX: Remove this begin/rescue before distributing your app
require 'mediatec'
rescue LoadError
  STDERR.puts "In development, you need to use `bundle exec bin/mediatec` to run your app"
  STDERR.puts "At install-time, RubyGems will make sure lib, etc. are in the load path"
  STDERR.puts "Feel free to remove this message from bin/mediatec now"
  exit 64
end

include GLI::App

program_desc 'Application d emprunt de films'

version Mediatec::VERSION

subcommand_option_handling :normal
arguments :strict

desc 'Describe some switch here'
switch [:s,:switch]

desc 'Execution en chargeant la bdd de films de voulue'
default_value 'bdd_films.txt'
arg_name 'bdd_films'
flag [:bddf]


desc 'Execution en chargeant la bdd de users de voulue'
default_value 'bdd_users.txt'
arg_name 'bdd_users'
flag [:bddu]

#TODO chargement de BDD dans classes

desc 'Emprunt d un film dont le nom est precise en argument par un utilisateur usrname'
arg_name 'film_name usrname'
command :borrow do |c|
  c.desc 'Prolongement d un emprunt'
  c.switch [:a,:again]

c.desc 'Reservation'
c.switch [:b,:book]

  #c.desc 'Describe a flag to borrow'
  #c.default_value 'default'
  #c.flag :f

  c.action do |global_options,options,args|

    # Your command logic here
     
    # If you have any errors, just raise them
    # raise "that command made no sense"
    #ici a-t-on besoin de faire l’appel à l’option globale ? quelle bdd utilisée ?
    bddf = global_options[:bddf]
    bddu = global_options[:bddu]
    again = options[:a]
    book = options[:book]
    film = args.shift
    user = args.shift

    res = Mediatec.borrow(film, user, FluxFilm.read(bddf), FluxUser.read(bddu))
    #Modification de la BDD
    FluxFilm.write(bddf, res)

    puts "borrow command ran"
  end
end

desc 'Retour d un film dont le nom est precise en argument'
arg_name 'film_name'
command :return do |c|
  c.action do |global_options,options,args|
bddf = global_options[:bddf]
    film = args.shift

    res = Mediatec.return(film, FluxFilm.read(bddf))
    #Modification de la BDD
	FluxFilm.write(bddf, res)

    puts "return command ran"
  end
end

desc 'Affiche la liste des emprunts et reservations en cours'
arg_name 'usrname'
command :check do |c|
c.desc 'Afficher les films reserves par l utilisateur usrname'
c.switch [:b,:booking]

  c.action do |global_options,options,args|
    bddf = global_options[:bddf]
    booking = options[:b]
    user = args.shift

    res = Mediatec.check(user, FluxFilm.read(bddf))
    #Affiche la liste des emprunts
    puts res
    
  end
end

desc 'Recherche de films, resultat affiche sous forme de liste'
command :search do |c|
c.desc 'Recherche par nom'
default_value ''
arg_name 'film_name'
c.flag [:name]

c.desc 'Recherche de films disponibles'
c.switch [:a,:available]

  c.action do |global_options,options,args|
bddf = global_options[:bddf]
    name = options[:name]
    available = options[:a]
    
    res = Mediatec.search(name, available, FluxFilm.read(bddf))
    puts res
  end
end

desc 'Cree un utilisateur ayant comme nom le username passe en argument'
arg_name 'admin_name usrname'
command :add_usr do |c|
c.desc 'Ajout de droits d admin'
c.switch [:a,:admin]

  c.action do |global_options,options,args|
    bddu = global_options[:bddu]
    admin_flag = options[:a]
    admin_name = args.shift
    usrname = args.shift

    res = Mediatec.add_usr(admin_flag, admin_name, usrname, FluxUser.read(bddu))
    #Modification de la BDD
	FluxUser.write(bddu,res)

    puts "addusr command ran"
  end
end

desc 'Ajout d un film a la mediatec'
arg_name 'admin_name film_name writer date'
command :add_film do |c|
  c.action do |global_options,options,args|
    bddf = global_options[:bddf]
    bddu = global_options[:bddu]
    admin_name = args.shift
    film_name = args.shift
    date = args.shift
    writer = args.shift

    res = Mediatec.add_film(admin_name, film_name, writer, date, FluxFilm.read(bddf), FluxUser.read(bddu))
    #Modification de la BDD
    FluxFilm.write(bddf, res)

    puts "addfilm command ran"
  end
end

pre do |global,command,options,args|
  # Pre logic here
  # Return true to proceed; false to abort and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  true
end

post do |global,command,options,args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |exception|
  # Error logic here
  # return false to skip default error handling
  true
end

exit run(ARGV)

